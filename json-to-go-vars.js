/*	
	JSON-to-Go
	by Matt Holt

	https://github.com/mholt/json-to-go

	A simple utility to translate JSON into a Go type definition.
*/

/*
	MODIFIED
*/

// For typed version using generated structs
function jsonToGoTypedVars(json, varName = "data", typeName = "AutoGenerated") {
	let data;
	let output = "";
	
	// Type naming state - copied from json-to-go-structs.js
	let globallySeenTypeNames = [];
	let currentPath = "";
	
	try {
		data = JSON.parse(json);
	} catch (e) {
		return {
			go: "",
			error: e.message
		};
	}
	
	// Generate the typed variable declaration
	output += `var ${varName} = &${typeName}${generateTypedGoValue(data, 0, typeName, "", [])}\n`;
	
	return {
		go: output
	};

	function checkTypedGoValue(value) {
		if (value === null) {
			return "nil";
		}

		switch (typeof value) {
			case "string":
				return false;
			case "number":
				return false;
			case "boolean":
				return false;
			case "object":
				return true;
		}
	}
	
	function generateTypedGoValue(value, depth, currentTypeName, parentPath, localSeenTypeNames) {
		const indent = "\t".repeat(depth);
		
		if (value === null) {
			return "nil";
		}
		
		switch (typeof value) {
			case "string":
				return `"${value.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t')}"`;
			
			case "number":
				return value.toString();
			
			case "boolean":
				return value.toString();
			
			case "object":
				if (Array.isArray(value)) {
					if (value.length === 0) {
						// For empty arrays, we need to determine the element type
						// This should match what json-to-go-structs generates
						return "{}";
					}
					
					// For arrays, we need to wrap in slice syntax
					let result = "[]" + getArrayElementTypeName(value, currentTypeName) + "{\n";
					for (let i = 0; i < value.length; i++) {
						// Generate the element value without adding type name - it's already in the slice declaration
						const elementValue = generateTypedGoValue(value[i], depth + 1, currentTypeName, parentPath, localSeenTypeNames);
						result += indent + "\t" + elementValue;
						result += ",\n";
					}
					result += indent + "}";
					return result;
				} else {
					// Object - use struct literal syntax
					const keys = Object.keys(value);
					if (keys.length === 0) {
						return "{}";
					}
					
					// Create a new seenTypeNames array for this struct scope
					const structSeenTypeNames = [];
					
					let result = "{\n";
					for (let i = 0; i < keys.length; i++) {
						const key = keys[i];
						const fieldName = formatFieldName(key);
						
						// Generate type name using the same logic as json-to-go-structs.js
						let fieldTypeName;
						if (checkTypedGoValue(value[key])) {
							// For nested objects, use global tracking with parent prefix
							fieldTypeName = uniqueTypeName(fieldName, globallySeenTypeNames, currentTypeName);
							globallySeenTypeNames.push(fieldTypeName);
						} else {
							// For non-objects, use local tracking without prefix
							fieldTypeName = uniqueTypeName(fieldName, structSeenTypeNames);
							structSeenTypeNames.push(fieldTypeName);
						}
						
						result += indent + "\t" + `${fieldTypeName}: `;
						
						// Check if the value is an array
						if (Array.isArray(value[key])) {
							// For arrays, generate the slice syntax
							result += generateTypedGoValue(value[key], depth + 1, fieldTypeName, currentTypeName, []);
						} else if (checkTypedGoValue(value[key])) {
							// For objects, add the type name
							result += fieldTypeName + generateTypedGoValue(value[key], depth + 1, fieldTypeName, currentTypeName, []);
						} else {
							// For primitives, just add the value
							result += generateTypedGoValue(value[key], depth + 1, currentTypeName, parentPath, localSeenTypeNames);
						}
						result += ",\n";
					}
					result += indent + "}";
					return result;
				}
			
			default:
				return "nil";
		}
	}
	
	// Helper function to determine the type name for array elements
	function getArrayElementTypeName(arr, parentTypeName) {
		if (arr.length === 0) {
			return "interface{}";
		}
		
		// Check if all elements are objects with the same structure
		const firstElem = arr[0];
		if (typeof firstElem === 'object' && !Array.isArray(firstElem) && firstElem !== null) {
			// For objects in arrays, the type name is typically the parent type name
			// This matches the behavior in json-to-go-structs.js
			return parentTypeName;
		}
		
		// For primitive types, return the Go type
		return goType(firstElem);
	}
	
	// Helper function to determine Go type - copied from json-to-go-structs.js
	function goType(val) {
		if (val === null)
			return "interface{}";

		switch (typeof val) {
			case "string":
				if (/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(\+\d\d:\d\d|Z)$/.test(val))
					return "time.Time";
				else
					return "string";
			case "number":
				if (val % 1 === 0) {
					if (val > -2147483648 && val < 2147483647)
						return "int";
					else
						return "int64";
				} else
					return "float64";
			case "boolean":
				return "bool";
			case "object":
				if (Array.isArray(val))
					return "slice";
				return "struct";
			default:
				return "interface{}";
		}
	}
	
	// Copied from json-to-go-structs.js
	function uniqueTypeName(name, seen, prefix = null) {
		if (seen.indexOf(name) === -1) {
			return name;
		}

		if (prefix) {
			name = prefix + name;
			if (seen.indexOf(name) === -1) {
				return name;
			}
		}

		let i = 0;
		while (true) {
			let newName = name + i.toString();
			if (seen.indexOf(newName) === -1) {
				return newName;
			}
			i++;
		}
	}
	
	// Copied from json-to-go-structs.js
	function formatFieldName(str) {
		str = formatNumber(str);
		let sanitized = toProperCase(str).replace(/[^a-z0-9]/ig, "");
		if (!sanitized) {
			return "NAMING_FAILED";
		}
		return formatNumber(sanitized);
	}
	
	// Copied from json-to-go-structs.js
	function formatNumber(str) {
		if (!str) {
			return "";
		} else if (str.match(/^\d+$/)) {
			str = "Num" + str;
		} else if (str.charAt(0).match(/\d/)) {
			const numbers = {
				'0': "Zero_", '1': "One_", '2': "Two_", '3': "Three_",
				'4': "Four_", '5': "Five_", '6': "Six_", '7': "Seven_",
				'8': "Eight_", '9': "Nine_"
			};
			str = numbers[str.charAt(0)] + str.substr(1);
		}
		return str;
	}
	
	// Copied from json-to-go-structs.js
	function toProperCase(str) {
		if (str.match(/^[_A-Z0-9]+$/)) {
			str = str.toLowerCase();
		}
		
		const commonInitialisms = [
			"ACL", "API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML", "HTTP",
			"HTTPS", "ID", "IP", "JSON", "LHS", "QPS", "RAM", "RHS", "RPC", "SLA",
			"SMTP", "SQL", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "UID", "UUID",
			"URI", "URL", "UTF8", "VM", "XML", "XMPP", "XSRF", "XSS"
		];
		
		return str.replace(/(^|[^a-zA-Z])([a-z]+)/g, function(unused, sep, frag) {
			if (commonInitialisms.indexOf(frag.toUpperCase()) >= 0) {
				return sep + frag.toUpperCase();
			} else {
				return sep + frag[0].toUpperCase() + frag.substr(1).toLowerCase();
			}
		}).replace(/([A-Z])([a-z]+)/g, function(unused, sep, frag) {
			if (commonInitialisms.indexOf(sep + frag.toUpperCase()) >= 0) {
				return (sep + frag).toUpperCase();
			} else {
				return sep + frag;
			}
		});
	}
}

// Command line interface
if (typeof module != 'undefined' && !module.parent) {
	let filename = null;
	let outputFile = null;
	let varName = "data";
	let typeName = "AutoGenerated";
	
	function generateGoVarsWithErrorHandling(json) {
		const output = jsonToGoTypedVars(json, varName, typeName);
			
		if (output.error) {
			console.error(output.error);
			process.exitCode = 1;
			return;
		}
		
		if (outputFile) {
			const fs = require('fs');
			fs.writeFileSync(outputFile, output.go, 'utf8');
			console.log(`Go variables written to ${outputFile}`);
		} else {
			process.stdout.write(output.go);
		}
	}
	
	// Parse command line arguments
	for (let i = 2; i < process.argv.length; i++) {
		const arg = process.argv[i];
		
		if (arg.startsWith('--var=')) {
			varName = arg.substring(6);
		} else if (arg.startsWith('--type=')) {
			typeName = arg.substring(7);
		} else if (!arg.startsWith('-')) {
			if (!filename) {
				filename = arg;
			} else if (!outputFile) {
				outputFile = arg;
			}
		}
	}
	
	if (filename) {
		const fs = require('fs');
		const json = fs.readFileSync(filename, 'utf8');
		generateGoVarsWithErrorHandling(json);
	} else {
		// Read from stdin
		const bufs = [];
		process.stdin.on('data', function(buf) {
			bufs.push(buf);
		});
		process.stdin.on('end', function() {
			const json = Buffer.concat(bufs).toString('utf8');
			generateGoVarsWithErrorHandling(json);
		});
	}
}

if (typeof module != 'undefined') {
	module.exports = { jsonToGoTypedVars };
}